
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}

module GenC where
import Ast
import qualified Exceptions
import qualified Data.Map as M
import Control.Exception
import Data.String.Utils
import Control.Monad
import TypeCheck
import Data.Maybe
import Data.Monoid
import Data.Either
import Exceptions

-- for random string generation
import System.Random
import System.IO.Unsafe


-- TODO make this a compiler flag.
readInitialBufferSize :: Int
readInitialBufferSize = 1024

--------------------------------------------------------------------------------


gen :: Env Block -> [Block] -> String
gen gamma bs =
         "#ifndef " <> headerGaurd <> "\n#define " <> headerGaurd
      <> "\n#include <string.h>\n"
      <> "#include <stdint.h>\n"
      <> "#include <endian.h>\n"
      <> "#include <stdlib.h>\n"
      <> "#include <stdio.h>\n"
      <> "#include <stdbool.h>\n"
      <> "#ifndef __BYTE_BLOCKS_UTILS__\n"
      <> "#define __BYTE_BLOCKS_UTILS__\n"
      <> "int grow_buff(char ** buff, size_t * len)\n"
      <> "{\n"
      <> "    size_t old_len = *len;\n"
      <> "    char *tmp = *buff;\n"
      <> "    *len *=  2;\n"
      <> "    *buff = malloc(*len);\n"
      <> "    if (*buff == NULL) return false;\n"
      <> "    memcpy(*buff, tmp, old_len);\n"
      <> "    free(tmp);\n"
      <> "    return true;\n"
      <> "}\n"
      <> "#endif // __BYTE_BLOCKS_UTILS__\n"
      <> "\n\n"
      <> "/* THIS CODE IS AUTO GENERATED BY THE BYTE BLOCKS COMPILER */\n"
      <> "/* SEE https://github.com/ethanpailes/bbc FOR MORE INFO */\n"
      <> "\n\n\n\n"
      <> concatMap (genStructure gamma) bs
      <> concatMap (genForwardDeclarations gamma) bs
      <> "\n\n\n\n"
      <> "/* BEGIN IMPLEMENTATION */"
      <> "\n\n\n\n"
      <> concatMap (genBlock gamma) bs
      <> "\n#endif\n"
          where headerGaurd = "BYTE_BLOCKS__" <>
                    take 20 (randomRs ('A','Z') $ unsafePerformIO newStdGen)

type GenFunc = Env Block -> Block -> String

{-
type NewGenFunc = Env Block -> Block -> [T.Text]

toGenFunc :: (NewGenFunc) -> GenFunc
toGenFunc f gamma block = (T.unpack . T.concat) $ f gamma block
-}

genBlock :: GenFunc
genBlock gamma b = unlines $ map (\genFun -> genFun gamma b) genFuns
    where
      genFuns = [ genSize
                , genPack
                , genUnpack
                , \_ _ -> "\n"
                , genWrite
                , genRead
                , genFree
                , \_ _ -> "\n\n"]

genForwardDeclarations :: GenFunc
genForwardDeclarations _ (Block bName _) =
     "int " <> bName <> "_size(const " <> bName <> " const * b);\n"
  <> "int " <> bName <> "_pack(const " <> bName <> " const * src, char * tgt);\n"
  <> "int " <> bName <> "_unpack_new(" <> bName <> " *tgt, const char const * src);\n"
  <> "int " <> bName <> "_write(const " <> bName <> " *src, FILE * f);\n"
  <> "int " <> bName <> "_read_new(" <> bName <> " *tgt, FILE * f);\n"
  <> "void " <> bName <> "_free(" <> bName <> " *tgt);\n"

genStructure :: GenFunc
genStructure _ (Block bName es) =
  "typedef struct " <> bName <> " {\n"
    <> concatMap fieldStr es
    <> "} " <> bName <> ";\n"
    where
      cFieldDecl cType fName = "    " <> cType <> (' ' : fName) <> ";\n"

      fieldStr (Blk _) = throw $ Exceptions.Unsupported "Nested blocks."
      fieldStr (Field name ty) =
        case ty of
          (BField i _ _) ->
             if i `elem` [8, 16, 32, 64]
               then cFieldDecl (cTypeOf ty) name
               else throw $ Exceptions.Unsupported "Unaligned bitfields."
          -- based on the fact that previously defined structs will already
          -- have been defined in the output file, we can safely use them
          -- as C types.
          (Tycon tyName) -> cFieldDecl tyName name
          (TyConapp t tys) ->
            case t of
              (Tycon "array") ->
                let [tag, content] = tys
                 in fieldStr (Field (name <> "_len") tag)
                 <> case content of
                      (BField {}) -> cFieldDecl (cTypeOf content <> " *") name
                      (Tycon tyName) -> "    " <>tyName<> " * " <> name <> ";\n"
                      (TyConapp {}) -> throw $ Exceptions.Unsupported
                                                    "Nested higher order types."
                      (SumTy {}) ->
                        throw $ Exceptions.Unsupported "genStructure Sum types."
                      (FixedArray {}) ->
                        throw $ Exceptions.Unsupported "genStructure Sum types."
              _ -> throw Exceptions.TypeError
          (SumTy tag opts) -> 
            fieldStr (Field (name <> "_tag") tag)
            <> "    union {\n"
            <> concatMap (("    " <>) . unionFields) opts
            <> "    } " <> name <> ";\n"
              where
                unionFields (t, n) = fieldStr (Field (name <> "_" <> show n) t)
          (FixedArray t num) ->
            "    " <> cTypeOf t <> " " <> name <> "[" <> show num <> "];\n"



genSize :: GenFunc
genSize gamma blk@(Block blkName entries) =
     "int " <> blkName <> "_size(const " <> blkName <> " const * b)\n"
  <> "{\n"
  <> "    int size = " <> show staticSize <> ";\n"
  <> (if isStatic then "" else concatMap dynamicSizeOf entries)
  <> "    return size;\n}"
    where blkSize = blockSize gamma blk
          isStatic = isRight blkSize
          staticSize = case blkSize of
                         (Right s) -> s
                         (Left s) -> s
          sizeCase fName (ty, num) =
            "    case " <> show num <> ":\n"
            <> (case ty of
                 (BField {}) -> 
                   "      size += "
                        <> show (fromJust (byteSizeOf gamma ty)) <> ";\n"
                 (Tycon tyName) ->
                   "      size += "<>tyName<> "_size(&(b->"<>elemName<> "));\n"
                      where elemName = fName <> "." <> fName <> "_" <> show num
                 _ -> throw Exceptions.TypeError)
            <> "      break;\n"

          dynamicSizeOf (Blk _) = throw $ Exceptions.Unsupported "Nested blocks"
          dynamicSizeOf (Field _ (BField {})) = ""
          dynamicSizeOf (Field fName (Tycon tyName)) = 
            -- We know from the typechecker that this type must be in gamma
            "    size += " <> tyName <> "_size(&(b->" <> fName <> "));\n"
          dynamicSizeOf (Field fName hot@(TyConapp ty tys)) =
            case ty of
              (Tycon "array") -> 
                let [tag, content] = tys
                    bSize = byteSizeOf gamma content
                 in case bSize of
                      (Just i) ->
                        "    size += (b->"<>fName <> "_len * " <> show i <> ");\n"
                      Nothing ->
                        case content of
                          (Tycon tyName) ->
                            let iter = fName <> "_iter"
                             in "    " <> cTypeOf tag <> " " <> iter <> " = 0;\n"
                            <> "    for("<>iter <> " = 0; " <> iter <> " < b->"<>fName
                                   <> "_len; ++"<> iter <> ") {\n"
                            <> "        size += " <> tyName
                             <> "_size(b->" <> fName <> " + " <> iter <> ");\n"
                            <> "    }\n"
                          _ -> throw Exceptions.TypeError
              _ -> throw $ Exceptions.MalformedHigherOrderType "genSize:" hot
          dynamicSizeOf (Field fName (SumTy _ opts)) =
               "    switch (b->" <> fName <> "_tag) {\n"
            <> concatMap (sizeCase fName) opts
            <> "    }\n"
          dynamicSizeOf (Field _ fa@(FixedArray {})) =
            "    size += " <> case byteSizeOf gamma fa of
                               (Just n) -> show n <> ";\n"
                               Nothing -> throw $ TypeError


-- Some blocks it is nice to have lying around for REPL testing

{-
fixedArrayBlockInner = Block "fixedArrayTestInner"
                    [Field "f1" (BField 8 Unsigned NativeEndian),
                    Field "f2" (FixedArray (BField 16 Unsigned BigEndian) 32)]

fixedArrayBlockOuter = Block "fixedArrayTestOuter"
                    [Field "f1" (BField 16 Unsigned NativeEndian),
                    Field "f2" (FixedArray (Tycon "fixedArrayBlockInner") 32)]

gamma' = M.insert "fixedArrayBlockInner" fixedArrayBlockInner TypeCheck.gammaInit

b2 = Block "test2"
        [Field "f1" (BField 32 Signed BigEndian),
         Field "f1.5" (FixedArray (BField 16 Unsigned NativeEndian) 20),
         Field "f2" (TyConapp (Tycon "array") [BField 16 Unsigned LittleEndian,
                                               BField 32 Signed BigEndian])]

gamma' = M.insert "test2" b2 TypeCheck.gammaInit

-}

genWrite :: GenFunc
genWrite gamma blk@(Block n _) =
     "int " <> n <> "_write(const " <> n <> " *src, FILE *f)\n"
  <> "{\n"
  <> "    int ret;\n"
  <> case blkSize of
       (Right bs) -> "    size_t blk_size = " <> show bs <> ";\n"
                 <> "    char buff[" <> show bs <> "];\n"
       (Left _) -> "    size_t blk_size = " <> n <> "_size(src);\n"
               <> "    char * buff = (char*) malloc(blk_size);\n"
  <> "    if(!"  <> n <> "_pack(src, buff)) return false;\n"
  <> "    ret = fwrite(buff, blk_size, 1, f);\n"
  <> freeStr
  <> "    return ret;\n}"
    where blkSize = blockSize gamma blk
          freeStr = if isLeft blkSize then "    free(buff);\n" else ""


genPack :: GenFunc
genPack gamma (Block n entries) =
     "int " <> n <> "_pack(const " <> n <> " const *src, char *tgt)\n{\n"
  <> "    size_t bytes_written = 0;\n"
  <>  packStmts entries
  <> "\n    return bytes_written;\n}"
    where 
      packStmt (Blk _) = throw Exceptions.TypeError
      packStmt (Field fName ty@(BField i s endianness)) =
            if i `elem` [8, 16, 32, 64]
              then "    *(" <> wordPtrStr <> "(tgt + bytes_written)) = "
                  <> endianFuncStr <> "(src->" <> fName
                  <> "); bytes_written += " <>
                                show (fromJust (byteSizeOf gamma ty))
                  <> ";\n"
              else throw $ Exceptions.Unsupported "Unaligned bitfields."
                where
                  wordSizeStr = show i
                  signStr = case s of
                              Signed -> ""
                              Unsigned -> "u"
                  endianFuncStr = 
                    if i <= 8
                       then ""
                       else case endianness of
                              BigEndian -> "htobe" <> wordSizeStr
                              LittleEndian -> "htole" <> wordSizeStr
                              NativeEndian -> ""
                  wordPtrStr = '(' : signStr <> "int" <> wordSizeStr <> "_t*)"

      packStmt (Field fName (Tycon tyName)) =
               "    bytes_written += " <> tyName <> "_pack(&(src->"
            <> fName <> "), (tgt + bytes_written));\n"
      packStmt (Field fName (TyConapp ty tys)) =
            case ty of
              (Tycon "array") ->
                  let [tag, content] = tys
                      boundCType = cTypeOf tag
                      iteratorName = fName <> "_iter"
                   in packStmt (Field (fName <> "_len") tag)
                   <> "    " <> boundCType <> " " <> iteratorName <> ";\n"
                   <> "    for(" <> iteratorName <> " = 0; "
                          <> iteratorName <> " < src->" <> fName <> "_len; ++" 
                          <> iteratorName <> ") {\n"
                   <> "    "
                      <> packStmt (Field (fName <> "[" <> iteratorName <> "]")
                                         content)
                   <> "    }\n"
              _ -> throw Exceptions.TypeError
      packStmt (Field fName (SumTy tag opts)) =
        let caseEntry (ty, num) =
                   "    case " <> show num <> ":\n"
                <> "  " <> packStmt
                          (Field (fName <> "." <> fName <> "_" <> show num) ty)
                <> "      break;\n"
         in packStmt (Field (fName <> "_tag") tag)
        <> "    switch (src->" <> fName <> "_tag) {\n"
        <> concatMap caseEntry opts
        <> "    }\n" 
      packStmt (Field fName (FixedArray (Tycon innerName) num)) =
        let iteratorName = fName <> "_iter"
         in "    for (size_t " <> iteratorName <> " = 0; " <> iteratorName <> " < "
                            <> show num <> "; ++" <> iteratorName <> ") {\n"
         <> "        bytes_written += " <> innerName <> "_pack(src->"
                            <> fName <> " + " <> iteratorName
                            <> ", tgt + bytes_written);\n"
         <> "    }\n"


      packStmt (Field fName fa@(FixedArray (BField {}) _)) =
        let bytesToCopy = case byteSizeOf gamma fa of
                            (Just bytes) -> bytes
                            Nothing -> throw $ TypeError
         in "    memcpy(tgt + bytes_written, src->" <> fName
             <> ", " <> show bytesToCopy <> "); bytes_written += "
             <> show bytesToCopy <> ";\n"
      packStmt (Field _ (FixedArray {})) = throw $ TypeError

      packStmts [] = ""
      packStmts (e:es) =
        case e of
          (Blk _) -> throw $ Exceptions.Unsupported "Nested blocks."
          field -> packStmt field <> packStmts es


{-
 - The generated code for read has to use a growing buffer to figure out how
 - to read in a given byte block.
 -}
genRead :: GenFunc
genRead gamma blk@(Block blkName _) = 
  let -- breaks entries up into chunks that we can read all at once
      readField fName fType = 
            "    " <> cTypeOf fType <> " " <> fName <> " = "
         <> endianReadFuncStr fType <> "(*( (( "
         <> cTypeOf fType <> " *) (buff + used)) - 1));\n"
      readSequences :: Block -> [[Entry]]
      readSequences block =
        let
          rs :: Block -> [[Entry]] -> [Entry] -> [[Entry]]
          rs (Block _ []) finished acc = reverse acc : finished
          rs (Block bName (e:es)) finished acc =
            case e of
              (Blk _) -> throw $ Exceptions.Unsupported "Nested blocks"
              (Field _ (BField {})) -> -- add the entry to the accumulator
                rs (Block bName es) finished (e : acc)
              (Field _ (FixedArray {})) -> 
                rs (Block bName es) finished (e : acc)
              (Field _ (Tycon tyName)) ->
                  let (Block _ blkEntries) = fromJust (tyName `M.lookup` gamma)
                   in readSequences (Block "BOGUS" (blkEntries <> es ))
              (Field _ (TyConapp ty _)) ->
                case ty of
                  (Tycon "array") ->
                    rs (Block bName es) ((reverse acc : finished) <> [[e]]) []
                  _ -> throw Exceptions.TypeError
              (Field _ (SumTy {})) ->
                rs (Block bName es) ((reverse acc : finished) <> [[e]]) []
           in filter (/= []) $ rs block [[]] []

      readVarLenTypeStr (Tycon tyName) rSeqTag =
        let childBlock = fromJust (tyName `M.lookup` gamma)
         in unlines -- when Haskell turns into lisp
             (map ("    " <>)
               (lines (concatMap readSequenceStr
                 (zip (readSequences childBlock)
                   (map (\i -> rSeqTag <> tyName <> show i)
                     [(0 :: Integer) .. ])))))
      readVarLenTypeStr _ _ = throw $ RealityBreach "genRead: readVarLenTypeStr: "

      readSequenceStr :: ([Entry], String) -> String
      readSequenceStr ([], _) =
        throw $ RealityBreach "genRead: readSequenceStr, empty read seq: "
      readSequenceStr ([Field fName (TyConapp (Tycon "array")
                                              [tag, content])], rSeqTag) =
        let lenStr = fName <> "_len"
         in readSequenceStr ([Field "ARRAY-BOGUS" tag], rSeqTag <> "a")
             <> readField lenStr tag
             <> (case byteSizeOf gamma content of
                  (Just n) ->
                    readFixedSequence len (rSeqTag <> "b") (len <> " && ")
                        where len = '(' : lenStr <> " * " <> show n <> ")"
                  Nothing ->
                       "    " <> cTypeOf tag <> " " <> iter <> ";\n"
                    <> "    for(" <> iter <> " = 0; " <> iter
                             <> " < " <> lenStr <> "; ++" <> iter <> ") {\n"
                    <> readVarLenTypeStr content rSeqTag
                    <> "    }\n"
                        where iter = fName <> "_iter")
      readSequenceStr ([Field fName (SumTy tag opts)], rSeqTag) =
        let caseStmt (ty, num) = 
                 "case " <> show num <> ":\n"
              <> (case byteSizeOf gamma ty of
                   (Just n) -> readFixedSequence (show n) (rSeqTag <> "b" <> show num) ""
                   Nothing -> readVarLenTypeStr ty rSeqTag )
              <> "    break;\n"
         in readSequenceStr ([Field "SUMTY-BOGUS" tag], rSeqTag <> "a")
         <> readField (fName <> "_tag") tag
         <> "    switch (" <> fName <> "_tag) {\n"
         <> unlines (map ("    " <>) (lines (concatMap caseStmt opts)))
         <> "    }\n"
      readSequenceStr (es, rSeqTag) =
        case blockSize gamma (Block "BOGUS" es) of
          (Right n) -> readFixedSequence (show n) rSeqTag ""
          (Left _) ->
            throw (RealityBreach "genRead: readSequenceStr, field block : ")
      readFixedSequence :: String -> String -> String -> String
      readFixedSequence len tag readGaurd =  
           tag <> ":\n"
        <> "    if (used + " <> len <> " > buff_len) {\n"
        <> "        if (grow_buff(&buff, &buff_len))\n"
        <> "            goto " <> tag <> ";\n"
        <> "        else\n"
        <> "            goto " <> endTag <> ";\n"
        <> "    } else {\n"
        <> "        if (" <> readGaurd <> "fread(buff + used, " <> len
                        <> ", 1, f) != 1) goto " <> endTag <> ";\n"
        <> "        used += " <> len <> ";\n"
        <> "    }\n"
      endTag = "END_READ" <> blkName
   in "int " <> blkName <> "_read_new(" <> blkName <> " *tgt, FILE *f)\n"
  <> "{\n"
  <> case blockSize gamma blk of
       (Right bs) -> "    size_t blk_size = " <> show bs <> ";\n"
              <> "    char buff[blk_size];\n"
              <> "    if (fread(buff, blk_size, 1, f) != 1) return false;\n"
              <> "    return " <> blkName <> "_unpack_new(tgt, buff);\n}"
       (Left _) ->
                 "    size_t buff_len = " <> show readInitialBufferSize <> ";\n"
              <> "    size_t used = 0;\n"
              <> "    int ret = false;\n"
              <> "    char *buff = malloc(buff_len);\n"
              <> "    if (!buff) return false;\n"
              <> concatMap readSequenceStr
                    (zip (readSequences blk)
                       (map (\i -> blkName <> "RSEQ" <> show i)
                            [(0 :: Integer) .. ]))
              <> "    ret = " <> blkName <> "_unpack_new(tgt, buff);\n"
              <> endTag <> ":\n"
              <> "    free(buff);\n"
              <> "    return ret;\n}"


genUnpack :: GenFunc
genUnpack gamma (Block n entries) = 
     "int " <> n <> "_unpack_new(" <> n <> " *tgt, const char const *src)\n{\n"
  <> "    size_t bytes_consumed = 0;\n"
  <> unpackStmts entries
  <> "\n    return bytes_consumed;\n}"
    where
      unpackStmt (Blk _) = throw $ Exceptions.Unsupported "Nested blocks."
      unpackStmt (Field fName ty@(BField i s _)) =
        let wordSizeStr = show i
            signStr = case s of
                        Signed -> ""
                        Unsigned -> "u"
            endianFuncStr = endianReadFuncStr ty
            wordPtrStr = '(' : signStr <> "int" <> wordSizeStr <> "_t*)"
         in if i `elem` [8, 16, 32, 64]
              then "    tgt->" <> fName
                  <> " = " <> endianFuncStr <> "(* (" <> wordPtrStr
                  <> "(src + bytes_consumed))); "
                  <> "bytes_consumed += "
                  <> show (fromJust (byteSizeOf gamma ty))
                  <> ";\n"
              else throw $ Exceptions.Unsupported "Unaligned bitfields."

      unpackStmt (Field fName (Tycon tyName)) =
            "    bytes_consumed += " <> tyName <> "_unpack_new(&(tgt->"
                <> fName <> "), (src + bytes_consumed));\n"
      unpackStmt (Field fName (TyConapp ty tys)) =
        case ty of
          (Tycon "array") ->
            let [tag, content] = tys
                iteratorName = fName <> "_iter"
             in "    " <> cTypeOf tag <>  " " <> iteratorName <> " = 0;\n"
             <> unpackStmt (Field (fName <> "_len") tag)
             <> (case content of
                  (BField {}) ->
                     "    tgt->" <> fName <> " = malloc(tgt->"
                                 <> fName <> "_len * "
                    <> show (fromJust (byteSizeOf gamma content)) <> ");\n"
                  (Tycon tyName) ->
                       "    tgt->" <> fName <> " = malloc(tgt->"
                              <> fName <> "_len * sizeof(" <> tyName <> "));\n"
                  _ -> throw (Exceptions.Unsupported
                             "Nested Higher Order types."))
             <> "    if (tgt->" <> fName <> "_len < 0) tgt->"
                                <> fName <> "_len = 0;\n" -- TODO impliment properly
             <> "    for(" <> iteratorName <> " = 0; "
                        <> iteratorName <> " < tgt->"
                        <> fName <> "_len; ++" <> iteratorName <> ") {\n"
             <> "    " <> unpackStmt
                      (Field (fName <> "[" <> iteratorName <> "]") content)
             <> "    }\n"
          _ -> throw Exceptions.TypeError
      unpackStmt (Field fName (SumTy tag opts)) =
        let caseStmt (ty, num) =
              ["case " <> show num <> ":"
               , rstrip (unpackStmt
                        (Field (fName <> "." <> fName <> "_" <> show num) ty))
               , "    break;"
               ]
         in unpackStmt (Field (fName <> "_tag") tag)
         <> "    switch (tgt->" <> fName <> "_tag) {\n"
         <> unlines (concatMap (map ("    " <>) . caseStmt) opts)
         <> "    }"
      unpackStmt (Field fName (FixedArray (Tycon innerName) num)) =
        let iteratorName = fName <> "_iter"
         in "    for (size_t " <> iteratorName <> " = 0; " <> iteratorName <> " < "
                            <> show num <> "; ++" <> iteratorName <> ") {\n"
         <> "        bytes_consumed += " <> innerName <> "_unpack_new(tgt->"
                            <> fName <> " + " <> iteratorName
                            <> ", src + bytes_consumed);\n"
         <> "    }\n"
      unpackStmt (Field fName fa@(FixedArray {})) =
        let bytesToCopy = case byteSizeOf gamma fa of
                            (Just bytes) -> bytes
                            Nothing -> throw $ TypeError
         in "    memcpy(tgt->" <> fName <>", src + bytes_consumed, "
             <> show bytesToCopy <> "); bytes_consumed += "
             <> show bytesToCopy <> ";\n"

      unpackStmts [] = ""
      unpackStmts (e:es) =
        case e of
          (Blk _) -> throw $ Exceptions.Unsupported "Nested Blocks."
          field -> unpackStmt field <> unpackStmts es


genFree :: GenFunc
genFree _ (Block bName entries) =
  let justs xs = foldr (\(s,n) a -> if s == Nothing then a else (fromJust s,n):a) [] xs
      freeStr :: Entry -> Maybe Name
      freeStr (Blk _) = throw $ Exceptions.Unsupported "Nested Blocks."
      freeStr (Field _ (BField {})) = Nothing
      freeStr (Field fName (Tycon tyName)) = 
        Just $ "    " <> tyName <> "_free(&(tgt->" <> fName <> "));\n"
      freeStr (Field fName (TyConapp (Tycon "array") [tag, content])) =
        Just 
          ((case content of
            (BField {}) -> "" -- No need to free each element
            (Tycon tyName) ->
                 "    " <> cTypeOf tag <> " " <> iter <> " = 0;\n"
              <> "    for(" <> iter <> " = 0; " <> iter <> " < "
                         <> "tgt->" <> fName <> "_len; ++" <> iter <> ") {\n"
              <> "        " <> tyName <> "_free(tgt->"
                              <> fName <> " + " <> iter <> ");\n"
              <> "    }\n"
              where iter = fName <> "_iter"
            (TyConapp {}) -> throw Exceptions.TypeError
            (SumTy {}) -> throw $ Exceptions.Unsupported "Sum Types."
            (FixedArray {}) -> "")
          <> "    free(tgt->" <> fName <> "); tgt->" <> fName <> " = NULL;\n")
            
      freeStr (Field _ hot@(TyConapp _ _)) = 
        throw $ Exceptions.MalformedHigherOrderType "genFree:" hot
      freeStr (Field fName (SumTy _ opts)) =
        let caseStmt (str, num) =
              [ "case " <> show num <> ":"
              , rstrip str
              , "    break;"]
            optStrs =
              justs $ map
                       (\(ty, n) ->
                         (freeStr
                           (Field (fName <> "." <> fName <> "_" <> show n)
                             ty), n))
                       opts
         in if optStrs == []
               then Nothing
               else Just ("    switch (tgt->" <> fName <> "_tag) {\n"
                         <> unlines (concatMap (map ("    " <>) . caseStmt) optStrs)
                         <> "    default:\n"
                         <> "        break;\n"
                         <> "    }\n")
      freeStr (Field _ (FixedArray {})) = Nothing
   in
     "void " <> bName <> "_free(" <> bName <> " *tgt)\n"
  <> "{\n"
  <> concat (mapMaybe freeStr entries)
  <> "}"


-- only take a BField as the type argument
endianReadFuncStr :: Ty -> String
endianReadFuncStr (BField i _ BigEndian) =
  if i <= 8 then "" else "be" <> show i <> "toh"
endianReadFuncStr (BField i _ LittleEndian) = 
  if i <= 8 then "" else "le" <> show i <> "toh"
endianReadFuncStr (BField _ _ NativeEndian) = ""
endianReadFuncStr _ = throw $ RealityBreach "endianFuncStr: "

-- Tries to compute the static size of the block. If the block is variable
-- length (contains an array or sum type) returns Left of the static size
-- of the block.
blockSize :: Env Block -> Block -> Either Int Int
blockSize gamma (Block _ entries) =
  let sizeOfType (Field _ (BField i _ _)) =
            if i `elem` [8, 16, 32, 64]
            then Right (i `div` 8)
            else throw $ Exceptions.Unsupported "Unaligned bitfields."
      sizeOfType (Field _ (Tycon tyName)) =
        let bs = blockSize gamma (fromJust (tyName `M.lookup` gamma))
         in case bs of
              (Right _) -> bs
              (Left _) -> Left 0
      sizeOfType (Field _ (TyConapp t tys)) =
            case t of
              (Tycon "array") ->
                let [tag, _] = tys
                 in case sizeOfType (Field "" tag) of
                      (Right x) -> Left x
                      (Left _) -> throw 
                          (RealityBreach "blockSize: sizeOfType, array: ")
              _               -> throw Exceptions.TypeError
      sizeOfType (Field _ (SumTy tag _)) =
          case sizeOfType (Field "BOGUS" tag) of
            (Right x) -> Left x
            (Left _) -> throw $ RealityBreach "blockSize: sizeOfType, SumTy: "
      sizeOfType (Field _ (FixedArray ty num)) =
        (pure . (*num) . fromJust) $ byteSizeOf gamma ty
      sizeOfType (Blk _) = throw $ Exceptions.Unsupported "Nested blocks."
      
      acc (Right a) (Right x) = Right (a + x)
      acc (Left a) (Right x) = Left (a + x)
      acc (Right a) (Left x) = Left (a + x)
      acc (Left a) (Left x) = Left (a + x)
   in foldl acc (Right 0) $ map sizeOfType entries

byteSizeOf :: Env Block -> Ty -> Maybe Int
byteSizeOf _     (BField i _ _) = Just $ i `div` 8
byteSizeOf gamma (Tycon tyName) =
      foldl
        (liftM2 (+))
        (Just 0)
        (map (byteSizeOf gamma . typeOf) entries)
    where (Block _ entries) = fromJust (tyName `M.lookup` gamma)
          typeOf (Blk _) = throw $ Exceptions.Unsupported "Nested blocks."
          typeOf (Field _ ty) = ty
byteSizeOf _     (TyConapp _ _) = Nothing
byteSizeOf _ (SumTy {}) = Nothing --throw $ Exceptions.Unsupported "byteSizeOf Sum Types."
byteSizeOf gamma (FixedArray ty num) =
  case byteSizeOf gamma ty of
    (Just n) -> pure $ n * num
    Nothing -> throw $ BadFixedArray ty

-- only works on bfields, helper function to compute the ctype of a given bfield
cTypeOf :: Ty -> String
cTypeOf (BField i s _) = let sign = if s == Signed then "" else "u"
                          in sign <> "int" <> show i <> "_t"
cTypeOf (Tycon tyName) = tyName
cTypeOf _              = "" -- unsafe
