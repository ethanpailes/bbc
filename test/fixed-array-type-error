#ifndef BYTE_BLOCKS__VHDTIYZDVLIDADZRUHMM
#define BYTE_BLOCKS__VHDTIYZDVLIDADZRUHMM
#include <string.h>
#include <stdint.h>
#include <endian.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#ifndef __BYTE_BLOCKS_UTILS__
#define __BYTE_BLOCKS_UTILS__
int grow_buff(char ** buff, size_t * len)
{
    size_t old_len = *len;
    char *tmp = *buff;
    *len *=  2;
    *buff = malloc(*len);
    if (*buff == NULL) return false;
    memcpy(*buff, tmp, old_len);
    free(tmp);
    return true;
}
#endif // __BYTE_BLOCKS_UTILS__


/* THIS CODE IS AUTO GENERATED BY THE BYTE BLOCKS COMPILER */
/* SEE https://github.com/ethanpailes/bbc FOR MORE INFO */




typedef struct inner {
    int32_t f3;
    uint64_t f4[256];
    uint8_t f5_tag;
    union {
        uint32_t f5_1;
        uint64_t f5_2;
    } f5;
} inner;
typedef struct outer {
    uint8_t f1;
    inner f4[256];
} outer;
int inner_size(const inner const * b);
int inner_pack(const inner const * src, char * tgt);
int inner_unpack_new(inner *tgt, const char const * src);
int inner_write(const inner *src, FILE * f);
int inner_read_new(inner *tgt, FILE * f);
void inner_free(inner *tgt);
int outer_size(const outer const * b);
int outer_pack(const outer const * src, char * tgt);
int outer_unpack_new(outer *tgt, const char const * src);
int outer_write(const outer *src, FILE * f);
int outer_read_new(outer *tgt, FILE * f);
void outer_free(outer *tgt);




/* BEGIN IMPLEMENTATION */



int inner_size(const inner const * b)
{
    int size = 2053;
    size += 2048;
    switch (b->f5_tag) {
    case 1:
      size += 4;
      break;
    case 2:
      size += 8;
      break;
    }
    return size;
}
int inner_pack(const inner const *src, char *tgt)
{
    size_t bytes_written = 0;
    *((int32_t*)(tgt + bytes_written)) = htole32(src->f3); bytes_written += 4;
    memcpy(tgt + bytes_written, src->f4, 2048); bytes_written += 2048;
    *((uint8_t*)(tgt + bytes_written)) = (src->f5_tag); bytes_written += 1;
    switch (src->f5_tag) {
    case 1:
      *((uint32_t*)(tgt + bytes_written)) = htole32(src->f5.f5_1); bytes_written += 4;
      break;
    case 2:
      *((uint64_t*)(tgt + bytes_written)) = htole64(src->f5.f5_2); bytes_written += 8;
      break;
    }

    return bytes_written;
}
int inner_unpack_new(inner *tgt, const char const *src)
{
    size_t bytes_consumed = 0;
    tgt->f3 = le32toh(* ((int32_t*)(src + bytes_consumed))); bytes_consumed += 4;
    memcpy(tgt->f4, src + bytes_consumed, 2048); bytes_consumed += 2048;
    tgt->f5_tag = (* ((uint8_t*)(src + bytes_consumed))); bytes_consumed += 1;
    switch (tgt->f5_tag) {
    case 1:
        tgt->f5.f5_1 = le32toh(* ((uint32_t*)(src + bytes_consumed))); bytes_consumed += 4;
        break;
    case 2:
        tgt->f5.f5_2 = le64toh(* ((uint64_t*)(src + bytes_consumed))); bytes_consumed += 8;
        break;
    }
    return bytes_consumed;
}


int inner_write(const inner *src, FILE *f)
{
    int ret;
    size_t blk_size = inner_size(src);
    char * buff = (char*) malloc(blk_size);
    if(!inner_pack(src, buff)) return false;
    ret = fwrite(buff, blk_size, 1, f);
    free(buff);
    return ret;
}
int inner_read_new(inner *tgt, FILE *f)
{
    size_t buff_len = 1024;
    size_t used = 0;
    int ret = false;
    char *buff = malloc(buff_len);
    if (!buff) return false;
innerRSEQ0:
    if (used + 2052 > buff_len) {
        if (grow_buff(&buff, &buff_len))
            goto innerRSEQ0;
        else
            goto END_READinner;
    } else {
        if (fread(buff + used, 2052, 1, f) != 1) goto END_READinner;
        used += 2052;
    }
innerRSEQ1a:
    if (used + 1 > buff_len) {
        if (grow_buff(&buff, &buff_len))
            goto innerRSEQ1a;
        else
            goto END_READinner;
    } else {
        if (fread(buff + used, 1, 1, f) != 1) goto END_READinner;
        used += 1;
    }
    uint8_t f5_tag = (*( (( uint8_t *) (buff + used)) - 1));
    switch (f5_tag) {
    case 1:
    innerRSEQ1b1:
        if (used + 4 > buff_len) {
            if (grow_buff(&buff, &buff_len))
                goto innerRSEQ1b1;
         