{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE OverloadedStrings #-}

module Parse where

import Ast
import Test.QuickCheck
import Text.ParserCombinators.Parsec
import Control.Monad
import Data.Char

-- Utility funciton to run a parser and satisfy the given function
runParserFresh ::GenParser tok () a -> [tok] -> (a -> Bool) -> Bool
runParserFresh p input sat = 
  case runParser p () "test snippet" input of
    Right res -> sat res
    Left _ -> False

reserved :: [String]
reserved = ["end", "block"]

parseName :: Parser Name
parseName = do
  first <- letter
  rest <- many (letter <|> digit)
  return n
  --if n `elem` reserved then return n else Left n ++ " is a reserved word"
    where n = first:rest
  --return $ first:rest

parseTy :: Parser Ty
parseTy = parseBField <|> try parseTyConapp <|> parseTycon
  -- where TODO
parseTyConapp = do
  ty <- parseTycon
  tys <- many1 (try (spaces >> parseTycon))
  return $ TyConapp ty tys
parseBField = do
  len <- many1 digit
  sign <- oneOf "su"
  endianness <- option 'n' $ oneOf "bln"
  return $ BField (read len)
            (if sign == 's' then Signed else Unsigned)
            (case endianness of
              'b' -> BigEndian
              'l' -> LittleEndian
              _ -> NativeEndian)
parseTycon = parseName >>= \n -> return $ Tycon n

prop_ParseTyParsesArbitraryType :: Ty -> Bool
prop_ParseTyParsesArbitraryType t =
  runParserFresh parseTy (show t) (== t)

parseBlock :: Parser Block
parseBlock = do
    _ <- string "block"
    n <- spaces >> parseName
    -- entries <- many1 (try (spaces >> parseEntry))
    entry <- spaces >> parseEntry
    _ <- spaces >> string "end"
    return $ Block n [entry] --entries
  --where TODO
parseEntry = parseField <|> (parseBlock >>= \b -> return (Blk b))
parseField = do
  n <- parseName
  _ <- spaces >> char ':' >> spaces
  ty <- parseTy
  return $ Field n ty


prop_ParseSingleLevelBlock :: Block -> Bool
prop_ParseSingleLevelBlock b =
  runParserFresh parseBlock (show b) (== b)


return []
testMod :: IO Bool
testMod = $quickCheckAll
